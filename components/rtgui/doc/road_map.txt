RTGUI for 1.1 路线图(排名不分先后)
1, 把 rtgui_thread 给去掉，变成 rtgui_application ，消除原来的 rtgui_thread +
mq 的模式。rtgui_application 记录当前依附的 panel，和 panel 的 extent(这个或许
不用，用时再取也好。)

2, workbench，window并成一个，其事件主循环并合并到rtgui_application中。
   2.1, window 作为有标题栏的 workbench
   2.2, 将其事件主循环移至 application 中。
   2.3, 将 window 的父类 toplevel 合并进 window 中。所有直接与服务器打交道的从
   window 继承。(或者将 toplevel 合并进 application 中，因为只有 application 才
   会和服务器打交道。)
   2.4 在创建 window 的时候需要指定 parent，如果为 RT_NULL，则此 window 为 root
   窗口，parent 为当前 rtgui_application。
   2.5 添加一个 FULL_PANEL 的 STYLE。指定此 STYLE 之后会自动填满整个 panel。其
   与 NO_TITLE 之类的合用可以达到之前 workbench 的效果。
   2.6 添加 rtgui_win_exec 方法，用来执行事件循环。(?)

3, 将 view 合并进 container，所有容器类继承 container。[note1](Done)

4, 事件循环完成后不主动销毁控件，销毁任务交由用户完成。但是有些自动销毁是必要的
，比如 container 自动销毁其包含的控件(Done)
   4.1 对于 window 的 onclose事件，保证在其回调函数中可以(但不是必须)安全销毁窗
   口。这个功能不保证能够实现。(onclose 是在将要关闭窗口的时候触发的，调用它之
   后 RTGUI 还要进行其他的设置和清理工作，所以不能在 onclose 里销毁窗口)(Cannot
   Implement)
   4.2 对 window 添加 RTGUI_WIN_STYLE_DESTROY_ON_CLOSE 。使得其在被关闭时自动销
   毁。注意：对同一 window 销毁两次会引起 segfault。同时，如果在创建时设置了
   RTGUI_WIN_STYLE_DESTROY_ON_CLOSE，close 窗口之后不要再去销毁窗口。

5, API 清理。更详细的文档。

6, 使 panel 退化为无窗口标题的 window，这样 server 就只记录 window 一种东西的位
置。

7, 指定名称的时候不再自己拷贝一份。(我觉得 90% 的情况下名称都是静态的字符串，这
时用 strdup其实并没有必要。)

8, 添加一些工业控制当中用到的波形、仪表之类的控件。

9, 在 application 中记录焦点控件，键盘事件由 application 直接投送。各个控件不记
录焦点控件。

----
[note1] 我们至少需要一种容器控件来盛放其他的控件，并且能把上层事件传递给被包含
的控件。实现这样的功能有一个就好，container 可以担当这个责任。其他需要放多个控
件的控件则可以继承/包含这个控件。然后多个容器控件轮换的，notebook 可以来做。
notebook可以是有标签和无标签的，有标签的对应一般的 tab 控件，无标签的对应 rtgui
for RTT 1.0 的 workbench+view。
